#!/usr/bin/env bash
main@bashbox%tuxdroid () 
{ 
    if test "${BASH_VERSINFO[0]}${BASH_VERSINFO[1]}" -lt 43; then
        { 
            printf '[!!!] \033[1;31m%s\033[0m[%s]: %s\n' ERROR 1 "At least bash 4.3 is required to run this." "Please upgrade bash or use the correct interpreter." "If you're on MacOS, you can install latest bash using brew or nix." 1>&2;
            exit 1
        };
    fi;
    function process::self::exit () 
    { 
        local _r=$?;
        ( kill -USR1 "$___self_PID" 2> /dev/null || : ) & exit $_r
    };
    function process::self::forcekill () 
    { 
        kill -9 "$___self_PID" 2> /dev/null
    };
    function log::error () 
    { 
        local _retcode="${2:-$?}";
        local _exception_line="$1";
        local _source="${BB_ERR_SOURCE:-"${BASH_SOURCE[-1]}"}";
        function ___errmsg () 
        { 
            printf '[!!!] \033[1;31m%s\033[0m[%s]: %s\n' ERROR "$_retcode" "$@" 1>&2
        };
        if [[ ! "$_exception_line" == \(*\) ]]; then
            { 
                ___errmsg "${_source##*/}[${BASH_LINENO[0]}]: ${BB_ERR_MSG:-"$_exception_line"}";
                if test -v BB_ERR_MSG; then
                    { 
                        printf "STACK TRACE: (TOKEN: %s)\n" "$_exception_line" 1>&2;
                        local -i _frame=0;
                        local _treestack='|-';
                        local _line _caller _source;
                        while read -r _line _caller _source < <(caller "$_frame"); do
                            { 
                                printf '%s >> %s\n' "$_treestack ${_caller}" "${_source##*/}:${_line}" 1>&2;
                                _frame+=1;
                                _treestack+='-'
                            };
                        done
                    };
                fi
            };
        else
            { 
                ___errmsg "${_source##*/}[${BASH_LINENO[0]}]: SUBSHELL EXITED WITH NON-ZERO STATUS"
            };
        fi;
        return "$_retcode"
    };
    \command unalias -a || true;
    set -eEuT -o pipefail;
    shopt -sq inherit_errexit expand_aliases nullglob;
    trap 'exit' USR1;
    trap 'BB_ERR_MSG="UNCAUGHT EXCEPTION" log::error "$BASH_COMMAND" || process::self::exit' ERR;
    ___self="$0";
    ___self_PID="$$";
    ___self_DIR="$(cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd)";
    ___MAIN_FUNCNAME='main@bashbox%tuxdroid';
    ___self_NAME="tuxdroid";
    ___self_CODENAME="tuxdroid";
    ___self_AUTHORS=("AXON <axonasif@gmail.com>");
    ___self_VERSION="1.0";
    ___self_DEPENDENCIES=(std::0.1.5);
    ___self_REPOSITORY="";
    ___self_BASHBOX_COMPAT="0.3.7~";
    function log::info () 
    { 
        echo -e "[%%%] \033[1;37minfo\033[0m: $@"
    };
    function log::warn () 
    { 
        echo -e "[***] \033[1;37mwarn\033[0m: $@"
    };
    function ensure::devNodes () 
    { 
        if [ ! -e "/dev/fd" ]; then
            ln -s /proc/self/fd /dev/;
        fi;
        if [ ! -e "/dev/stdin" ]; then
            ln -s /proc/self/fd/0 /dev/stdin;
        fi;
        if [ ! -e "/dev/stdout" ]; then
            ln -s /proc/self/fd/1 /dev/stdout;
        fi;
        if [ ! -e "/dev/stderr" ]; then
            ln -s /proc/self/fd/2 /dev/stderr;
        fi;
        if [ ! -e "/dev/tty0" ]; then
            ln -s /dev/null /dev/tty0;
        fi;
        if [ ! -e "/dev/net/tun" ]; then
            mkdir -p /dev/net;
            mknod /dev/net/tun c 10 200;
        fi;
        if [ ! -e "/dev/loop0" ] && [ -e "/dev/block/loop0" ]; then
            ln -sf /dev/block/loop* /dev/;
        fi
    };
    function mount::umountTree () 
    { 
        local _tree="$1";
        local _mountpoint;
        local _mountdump;
        log::info "Cleanly unmounting if necessary";
        _mountdump="$(grep "$_tree" /proc/mounts || true)";
        if test -n "$_mountdump"; then
            { 
                mapfile -t _mountpoints < <(echo "$_mountdump" | awk '{print $2}' | grep '^/.*' | tac);
                for _mountpoint in "${_mountpoints[@]}";
                do
                    while mountpoint -q "$_mountpoint" || grep -q " ${_mountpoint} " /proc/mounts; do
                        { 
                            log::info "Unmounting $_mountpoint";
                            umount -df "$_mountpoint"
                        };
                    done;
                done;
                while grep -q "$_tree" /proc/mounts; do
                    { 
                        umount -df "$_tree"
                    };
                done
            };
        fi
    };
    function user::get_id () 
    { 
        local _user_name="${1%%:*}";
        echo $(grep -m1 "^${_user_name}:" "$_distro_root/etc/passwd" | awk -F: '{print $3}')
    };
    function user::get_name () 
    { 
        local _user_id="${1%%:*}";
        echo $(grep -m1 "^.*:.*:${_user_id}" "$_distro_root/etc/passwd" | awk -F: '{print $1}')
    };
    function user::get_home () 
    { 
        local _user_name="${1%%:*}";
        if test "$_user_name" == root; then
            { 
                echo "/root"
            };
        else
            { 
                echo "/home/$_user_name"
            };
        fi
    };
    function user::get_shell () 
    { 
        local _user_name="$1";
        echo $(grep -m1 "^${_user_name}:" "${_distro_root}/etc/passwd" | awk -F: '{print $7}')
    };
    function chroot::run_prog () 
    { 
        local _chroot_path=":/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin";
        local _user_id="0";
        local _userspec="${_user_id}:${_user_id}";
        if test -v CUSER; then
            { 
                if [[ "$CUSER" =~ [Aa-zZ] ]]; then
                    { 
                        local _get_id;
                        _get_id="$(user::get_id "${CUSER}")";
                        _userspec="${_get_id}:${_get_id}"
                    };
                else
                    { 
                        _userspec="$CUSER";
                        CUSER="$(user::get_name "$CUSER")"
                    };
                fi
            };
        fi;
        local _user_home && _user_home="$(user::get_home "${CUSER:-"root"}")";
        env -i HOME="$_user_home" PATH="$_chroot_path" TERM=xterm-256color "$(command -v chroot)" --userspec=$_userspec -- "$_distro_root" "$@"
    };
    function chroot::stop () 
    { 
        local _chroot_pids _pid;
        mapfile -t _chroot_pids < <(busybox lsof | grep "$_distro_root" 		| awk '{print $1}' | uniq || true);
        for _pid in "${_chroot_pids[@]}";
        do
            { 
                log::info "Killing $_pid";
                kill -9 "$_pid"
            };
        done;
        mount::umountTree "$_distro_root"
    };
    function chroot::start () 
    { 
        echo "Starting the container ...";
        chroot::stop;
        if grep -qE '/dev/block/.* /data .*nosuid|/dev/block/.* /data .*nodev|/dev/block/.* /data .*noexec' /proc/mounts; then
            { 
                mount -oremount,suid,dev,exec /data || { 
                    log::warn "Tried to remount as suid but failed, so continuing..." && { 
                        mount --bind "$_distro_root" "$_distro_root";
                        mount -o remount,dev,exec,suid "$_distro_root"
                    }
                }
            };
        fi;
        if test "${DRY_RUN:-}" == true; then
            { 
                log::info "Initializing dry-run mode, happy experimenting!";
                local _overlay_root="${_distro_root%/*}/.tuxdroid_overlay";
                rm -rf "$_overlay_root";
                mkdir -p -m 0755 "$_overlay_root/worker" "$_overlay_root/upper";
                mount -t overlay overlay -o lowerdir="$_distro_root",upperdir="$_overlay_root/upper",workdir="$_overlay_root/worker" "$_distro_root"
            };
        fi;
        log::info "Mounting /proc" && mount -t proc proc "$_distro_root/proc";
        log::info "Mounting /sys" && mount -t sysfs sys "$_distro_root/sys";
        log::info "Binding /dev" && mount --bind /dev "$_distro_root/dev" && ensure::devNodes;
        if ! mountpoint -q "$_distro_root/dev/shm" 2> /dev/null; then
            { 
                log::info "Creating /dev/shm";
                mkdir -p -m 1777 "$_distro_root/dev/shm" && mount -o rw,nosuid,nodev,mode=1777 -t tmpfs shm "$_distro_root/dev/shm"
            };
        fi;
        if ! mountpoint -q "$_distro_root/dev/pts" 2> /dev/null; then
            { 
                log::info "Creating /dev/pts";
                if mountpoint -q /dev/pts 2> /dev/null; then
                    { 
                        mount --bind /dev/pts "$_distro_root/dev/pts"
                    };
                else
                    { 
                        mkdir -p "$_distro_root/dev/pts" && mount -o rw,nosuid,noexec,gid=5,mode=620,ptmxmode=000 -t devpts devpts "$_distro_root/dev/pts"
                    };
                fi
            };
        fi;
        rm -rf "$_distro_root/tmp";
        mkdir -m 0777 -p "$_distro_root/tmp";
        chmod +t "$_distro_root/tmp";
        if test -d "$_distro_root/home/axon"; then
            mkdir -p "$_distro_root/home/axon/Common";
            mount --bind /data/linux/common "$_distro_root/home/axon/Common";
        fi;
        _resolv_conf="$_distro_root/etc/resolv.conf";
        rm "$_resolv_conf" || true;
        for _dns in "1.1.1.1" "1.0.0.1";
        do
            echo "nameserver $_dns" >> "$_resolv_conf";
        done;
        if ! grep -q "^127.0.0.1" "$_distro_root/etc/hosts"; then
            echo '127.0.0.1 localhost' >> "${_distro_root}/etc/hosts";
        fi;
        function dbus_daemon_start () 
        { 
            log::info "Starting dbus system daemon";
            rm -rf "$_distro_root/run/dbus" && mkdir -p -m 0755 "$_distro_root/run/dbus";
            CUSER=root chroot::run_prog dbus-daemon --system --fork
        };
        if test -n "${COMPONENTS:-}"; then
            { 
                local _component;
                for _component in $COMPONENTS;
                do
                    { 
                        case "$_component" in 
                            ssh)
                                log::info "Starting ssh daemon";
                                local sshd_config;
                                sshd_config="$_distro_root/etc/ssh/sshd_config";
                                sed -i -E 's/#?PasswordAuthentication .*/PasswordAuthentication yes/g' "${sshd_config}";
                                sed -i -E 's/#?PermitRootLogin .*/PermitRootLogin yes/g' "${sshd_config}";
                                sed -i -E 's/#?AcceptEnv .*/AcceptEnv LANG/g' "${sshd_config}";
                                mkdir -p "$_distro_root/run/sshd" "$_distro_root/var/run/sshd";
                                if [ $(ls "${_distro_root}/etc/ssh/" | grep -c key) -eq 0 ]; then
                                    chroot::run_prog ssh-keygen -A > /dev/null;
                                fi;
                                chroot::run_prog sh -c '$(which sshd) -p 22'
                            ;;
                            x11)
                                dbus_daemon_start;
                                log::info "Starting X11";
                                log::info "Waiting for X11 socket";
                                until ps -fA | grep -v grep | grep -q '/x.org.server/.*/xsel'; do
                                    { 
                                        sleep 1
                                    };
                                done;
                                CUSER=axon chroot::run_prog dtach -n /tmp/tuxdroid_x11.sock -Ez sh -c '{ cd && chmod +x .xinitrc && exec $PWD/.xinitrc 2>&1; } > /tmp/dbus.log 2>&1'
                            ;;
                            vnc)
                                dbus_daemon_start;
                                log::info "Starting VNC";
                                CUSER=axon chroot::run_prog dtach -n /tmp/tuxdroid_vnc.sock -Ez sh -c '{ cd && chmod +x .xinitrc && exec vncserver :0 2>&1; } > /tmp/vncserver.log 2>&1'
                            ;;
                            fb)
                                dbus_daemon_start;
                                log::info "Starting framebuffer";
                                sync;
                                sync;
                                sync;
                                ( sync;
                                sync;
                                sync ) & log::info "Launching framebuffer vsync daemon";
                                set +eEuT;
                                ( exec {sleep_fd}<> <(:);
                                while echo 0 > /sys/class/graphics/fb0/rotate || true; do
                                    read -t 0.030 -u $sleep_fd;
                                    continue;
                                done ) & export _fbrefresh_daemon=$! && disown && set -eEuT;
                                log::info "Launching Xorg xserver";
                                ( CUSER=axon chroot::run_prog dtach -n /tmp/xinit.sock -Ez sh -l -i -c '{ cd && exec xinit -- :0 -dpi 100 -sharevts vt0 2>&1; } >/tmp/xinit.log 2>&1' ) & log::info "Killing surfaceflinger";
                                ( _graphics_pids=$(ps -fA | grep -v grep | grep 'graphics' | awk '{print $2}');
                                sleep 3;
                                pkill -STOP surfaceflinger;
                                sleep 3;
                                pkill -STOP system_server;
                                setprop ctl.stop surfaceflinger;
                                sleep 5;
                                setprop ctl.stop zygote;
                                sleep 5;
                                pkill -CONT system_server;
                                while test -e "$_distro_root/tmp/xinit.sock"; do
                                    { 
                                        sleep 10
                                    };
                                done;
                                setprop ctl.start zygote;
                                setprop ctl.start surfaceflinger;
                                kill -9 "$_fbrefresh_daemon" ) & disown
                            ;;
                        esac
                    };
                done
            };
        fi
    };
    function chroot::enter_shell () 
    { 
        local _mountpoint;
        for _mountpoint in dev proc sys;
        do
            { 
                if ! mountpoint -q "$_distro_root/$_mountpoint" && ! grep -q " ${_mountpoint} " /proc/mounts; then
                    { 
                        chroot::start;
                        break
                    };
                fi
            };
        done;
        chroot::run_prog sh -c "cd && $(user::get_shell ${CUSER:-root}) -l" || log::warn "Container environment shell exited with error code $?"
    };
    function distro::configure () 
    { 
        : "${DISTRIB:="archlinux"}";
        if test $DISTRIB == archlinux; then
            echo 'Server = http://sg.mirror.archlinuxarm.org/$arch/$repo' > "$_distro_root/etc/pacman.d/mirrorlist";
        else
            echo 'Server = http://mirror.xeonbd.com/manjaro/arm-stable/$repo/$arch' > "$_distro_root/etc/pacman.d/mirrorlist";
        fi;
        local _key;
        for _key in "DisableDownloadTimeout";
        do
            { 
                if grep -q "^#${_key}" "$_distro_root/etc/pacman.conf"; then
                    { 
                        sed -i "s|^#${_key}|${_key}|" "$_distro_root/etc/pacman.conf"
                    };
                else
                    { 
                        sed -i "s|^\[options\]|\[options\]\n${_key}|" "$_distro_root/etc/pacman.conf"
                    };
                fi
            };
        done;
        for _key in "CheckSpace";
        do
            { 
                sed -i "s|^${_key}|#${_key}|" "$_distro_root/etc/pacman.conf"
            };
        done;
        CUSER=root chroot::run_prog pacman-key --init;
        local _keyring _found_keyring;
        for _keyring in archlinuxarm archlinux manjaro-arm;
        do
            { 
                if test -e "$_distro_root/usr/share/pacman/keyrings/$_keyring"; then
                    { 
                        _found_keyring+=($_keyring)
                    };
                fi
            };
        done;
        CUSER=root chroot::run_prog pacman-key --populate "${_found_keyring[@]}";
        local ARCHLINUX_PACKAGES=(sudo xorg xdg-utils gnome-keyring python base base-devel htop firefox neovim strace tree lsof wget rsync usbutils git github-cli file coreutils e2fsprogs grep wget cdrtools squashfs-tools xclip scrot neofetch busybox fish code feh ranger openssh tigervnc bash-completion pcmanfm yay mesa-demos chromium xf86-video-fbdev xf86-input-evdev xfce4 xfce4-netload-plugin tmux);
        if test $DISTRIB == manjaro; then
            ARCHLINUX_PACKAGES+=(manjaro-release);
        fi;
        until CUSER=root chroot::run_prog pacman -Syyuu --noconfirm --needed "${ARCHLINUX_PACKAGES[@]}"; do
            { 
                continue
            };
        done;
        CUSER=root chroot::run_prog chmod -f 4755 /usr/share/code/chrome-sandbox;
        CUSER=root chroot::run_prog setcap -r /usr/bin/gnome-keyring-daemon;
        local _dtach_bin && _dtach_bin="$(command -v dtach)";
        cat "$_dtach_bin" > "$_distro_root/usr/bin/dtach";
        chmod 755 "$_distro_root/usr/bin/dtach";
        log::info "Configuring LOCALE";
        echo 'en_US.UTF-8 UTF-8' > "$_distro_root/etc/locale.gen";
        echo 'LANG=en_US.UTF-8' > "$_distro_root/etc/locale.conf";
        CUSER=root chroot::run_prog locale-gen;
        local LOCALE="en_US.UTF-8";
        if echo ${LOCALE} | grep -q '\.'; then
            local inputfile=$(echo ${LOCALE} | awk -F. '{print $1}');
            local charmapfile=$(echo ${LOCALE} | awk -F. '{print $2}');
            CUSER=root chroot::run_prog localedef -i ${inputfile} -c -f ${charmapfile} ${LOCALE};
        fi;
        CUSER=root chroot::run_prog ln -sf "/usr/share/zoneinfo/Asia/Dhaka" "/etc/localtime";
        hwclock --systohc;
        log::info "Configuring AXON";
        if ! grep -q axon "$_distro_root/etc/group"; then
            CUSER=root chroot::run_prog groupadd --gid 60000 axon;
            CUSER=root chroot::run_prog useradd --uid 60000 --gid 60000 --create-home --shell /bin/bash axon;
            echo 'axon:q' | CUSER=root chroot::run_prog chpasswd;
        fi;
        log::info "Configuring SU";
        local item pam_su;
        for item in /etc/pam.d/su /etc/pam.d/su-l;
        do
            pam_su="${_distro_root}/${item}";
            if [ -e "${pam_su}" ]; then
                if ! grep -q '^auth.*sufficient.*pam_succeed_if.so uid = 0 use_uid quiet$' "${pam_su}"; then
                    sed -i '1,/^auth/s/^\(auth.*\)$/auth\tsufficient\tpam_succeed_if.so uid = 0 use_uid quiet\n\1/' "${pam_su}";
                fi;
            fi;
        done;
        log::info "Configuring SUDO";
        local _sudo_str="axon ALL=(ALL:ALL) NOPASSWD:ALL";
        if ! grep -q "$_sudo_str" "$_distro_root/etc/sudoers"; then
            echo "$_sudo_str" >> "$_distro_root/etc/sudoers";
        fi
    };
    function enter::ns_one () 
    { 
        if test "${NS_ONE:-}" == "true"; then
            { 
                return 0
            };
        fi;
        function ns::cut_id () 
        { 
            local _str="$1";
            _str="${_str#*[}" && _str="${_str%]*}";
            echo "$_str"
        };
        if test "$(ns::cut_id "$(readlink -f /proc/1/ns/mnt)")" != "$(ns::cut_id "$(readlink -f /proc/self/ns/mnt)")"; then
            { 
                log::info "Entering mount namespace of PID 1";
                export NS_ONE=true;
                exec nsenter -t 1 "$0" "$@"
            };
        fi
    };
    function main () 
    { 
        function parse_arg () 
        { 
            local _arg;
            for _arg in "$@";
            do
                { 
                    case "$_arg" in 
                        --components=*)
                            COMPONENTS="${_arg##*=}";
                            shift
                        ;;
                        --root=*)
                            ROOT="${_arg##*=}";
                            shift
                        ;;
                        --user=*)
                            CUSER="${_arg##*=}";
                            shift
                        ;;
                        --distrib=*)
                            DISTRIB="${_arg##*=}";
                            shift
                        ;;
                        --dry-run)
                            DRY_RUN=true;
                            shift
                        ;;
                    esac
                };
            done;
            _distro_root="$(readlink -f "${ROOT}")"
        };
        case "${!#}" in 
            start)
                enter::ns_one "$@";
                parse_arg "$@";
                chroot::start
            ;;
            stop)
                enter::ns_one "$@";
                parse_arg "$@";
                chroot::stop
            ;;
            enter-shell)
                enter::ns_one "$@";
                parse_arg "$@";
                chroot::enter_shell
            ;;
            configure)
                enter::ns_one "$@";
                parse_arg "$@";
                chroot::start;
                distro::configure
            ;;
        esac
    };
    main "$@";
    wait;
    exit
}
"main@bashbox%tuxdroid" "$@";
